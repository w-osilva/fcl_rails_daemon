#!/usr/bin/env ruby
require 'fileutils'
require 'fcl_rails_daemon/config'

base = DAEMON_ROOT
config_dir = "config"
config_dir = File.join(base, config_dir)
FileUtils.mkdir_p(config_dir) unless File.directory?(config_dir)
config_file = File.join(config_dir, 'fcld_rails_daemon.rb')

if ARGV.include? "--configure"
  config_file_content = <<-FILE
# Carrega arquivo de environment (projeto rails)
if File.exist?(File.join("#{config_dir}", "environment"))
  require File.join("#{config_dir}", "environment")
end

# Para registrar seus comandos é necessário adicioná-los conforme o exemplo abaixo
# É necessário que seja informado o nome do comando e qual a classe ao qual ele representa
# Ex:
# FclRailsDaemon::Registrador.add(comando: 'comando_exemplo', classe: ComandoExemplo)
  FILE

  File.open(config_file, 'wb') {|f| f.write(config_file_content) } unless File.exist?(config_file)

  command_sample_content = <<-FILE
class ComandoExemplo < FclRailsDaemon::Daemon

  # Obrigatóriamente é necessário implementar o método "initialize"
  def initialize
    # Definir o parametro "task" (nome que será referenciado no comando digitado no terminal).
    #
    # O parametro "log" é opcional mas sugiro que seja definido um log para cada comando para evitar que muitos comandos
    # escrevam no log deafult (caso tenha# muitos comandos)
    super(task: "comando_exemplo", log: "log/comando_exemplo.log")
  end

  # Obrigatóriamente é necessário implementar o método self.help
  def self.help
    # Retornar Hash com "descricao" e "exemplo"
    {
      descricao: "Descrição do comando comando_exemplo :) - Executado a cada 1 min",
      exemplo: ["--task comando_exemplo start | stop | restart | status"]
    }
  end

  # Obrigatóriamente é necessário implementar o método run
  def run
    # Chamar o método run da classe pai (super) passando um bloco que vai conter seu código
    super do
      # Caso deseje que o seu comando fique executando repetidamente coloque dentro de um loop
      loop do
        # Escreva seu código aqui!!
        # Não use Process.exit(true), exit(), abort() em seu codigo pois infere na morte do processo do Daemon
        puts "Está executando comando_exemplo!  :)"

        # Espera em segundos antes de executar seu comando outra vez
        # Util no caso de simular um processo cronológico (esse exemplo vai executar o comando a cada 10 segundos)
        sleep(10)
      end
    end
  end

end

  FILE

  commands_dir = DAEMON_CONFIG['command_path']
  commands_dir = File.join(base, commands_dir)
  FileUtils.mkdir_p(commands_dir) unless File.directory?(commands_dir)

  command_file = File.join(commands_dir, 'comando_exemplo.rb')
  File.open(command_file, 'wb') {|f| f.write(command_sample_content) } unless File.exists?(command_file)

  log_dir = "log"
  log_dir = File.join(base, log_dir)
  FileUtils.mkdir_p(log_dir) unless File.directory?(log_dir)

  pids_dir = File.join(base, "tmp/pids")
  pids_file = File.join(base, DAEMON_CONFIG['pids_file'])
  FileUtils.mkdir_p(pids_dir) unless File.directory?(pids_dir)
  File.open(pids_file, 'wb') {|f| f << "default:" } unless File.exist?(pids_file)

  puts "[Ok] Gem foi configurada!"
  exit
end

unless File.exist?(config_file)
  puts "[Ooops] Gem ainda não foi configurada... Para configurar execute o comando fcld --configure "
  exit
end

require 'fcl_rails_daemon'
require 'fcl_rails_daemon/version'

FclRailsDaemon::Gerenciador.run(ARGV)